/*
Pratica 1: Implementacao de um Middleware tolerante a falha para alocacao dinamica de memoria
Alunos: Ellen Priscila Borges Oliveira RA 69554
        Juliana de Paula Nader
*/

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>


typedef struct no_lista{
  int dado;
  struct no_lista *ant; /* quarda a posicao do elemento anterior na lista */
  struct no_lista *prox; /* quarda a posicao do proximo elemento na lista */
}NO;

typedef struct Lista{
    NO* primeiro;
    NO* ultimo;
    int tamanho;     /*guarda o tamanho da lista*/
}LDE;

/*----------------- Funcoes para a Lista encadeada-----------------*/

void InicializaLista(LDE *L){

  L->primeiro = NULL;
  L->ultimo = NULL;
  L->tamanho = 0;

}

NO* Busca(LDE *L, int dado){

    NO *temp;

    for (temp = L->primeiro; temp!=NULL;temp = temp->prox) {
        if (temp->dado == dado) {
          return temp;
        }
    }
    return NULL; /* não achou o no */


}

NO* CriaNovoNo(int dado){
    NO *novo = malloc(sizeof(NO));
    novo->dado = dado;
    novo->ant = NULL;
    novo->prox = NULL;
    return novo;
}


//insere um novo no no final da lista
int InsereNO(LDE *L, int dado){ //void(*dado)() ){
    NO*novo = CriaNovoNo(dado);
    if(novo==NULL)
        return -1;
    //se a lista esta vazia
    if(L->primeiro==NULL && L->ultimo==NULL){
        L->primeiro = novo;
        L->ultimo = novo;
        L->tamanho++;
        return 0;
    }
    //caso a lista possua um ou mais elementos
    else{
        if(Busca(L,dado)==NULL){
            novo->prox = NULL;
            novo->ant= L->ultimo;
            L->ultimo->prox = novo;
            L->ultimo = novo;
            L->tamanho++;
            return 0;
        }else return -1;
    }
}

int RemoveNO(LDE *L, int dado){
    if(L->tamanho==0) //se a lista esta vazia
        return -1;
    NO* temp = Busca(L,dado);
    if(temp!=NULL){
        //remove começo
        if(temp->ant==NULL){
            L->primeiro = temp->prox;
            L->primeiro->ant = NULL;

        }//remove final
        else if(temp->prox==NULL){
            L->ultimo= temp->ant;
            temp->ant->prox=NULL;
            L->tamanho--;

        }//no meio
        else {
            temp->ant->prox = temp->prox;
            temp->prox->ant = temp->ant;

        }
        L->tamanho--;
        temp->prox = NULL;
        temp->ant= NULL;
        free(temp);
        return 0;
    }else return -1;

}

void DestroiLista(LDE* L){
    NO* no = L->primeiro;
    NO* temp;

    while (no != NULL) {
        temp = no->prox;
        free(no);
        no = temp;
    }
}
void ImprimeLista (LDE *L) {
    if(L!=NULL){
        Imprime(L->primeiro);
    }
}

void Imprime(NO* temp){

    if(temp!=NULL){
        printf("Valor = [%d]\n", temp->dado);
        Imprime(temp->prox);
    }
}

/*----------------- Funcoes para o mid-----------------*/
/*

void *(*_malloc)(size_t) = NULL;

void *malloc(size_t size){

	if (!_malloc)
		_malloc = dlsym(RTLD_NEXT, "malloc");

	fprintf(stderr, "WRAPPER: malloc(%d) = %p\n",(int)size, p);
	void *p = _malloc(size);

	//INSERE P NUMA LISTA duplamente encadeada
	return p;
}

void * (*_calloc)(size_t, size_t) = NULL;

void *calloc(size_t nmemb, size_t size){
	if (!_calloc)
		_calloc = dlsym(RTLD_NEXT, "calloc");

	fprintf(stderr, "WRAPPER: mclloc(%d) = %p\n",(int)size, p);
	void *p = _calloc(nmemb, size);

	//INSERE P NUMA LISTA duplamente encadeada
	return p;

}


void * (*_realloc)(void *, size_t) = NULL;

void *realloc(void *ptr, size_t size){
	if (!_realloc)
		_realloc = dlsym(RTLD_NEXT, "realloc");

	fprintf(stderr, "WRAPPER: realloc(%d) = %p\n",(int)size, p);
	void *p = _realloc(ptr, size);

	//INSERE P NUMA LISTA duplamente encadeada
	return p;


}



void (*_free)(void *) = NULL;

void free(void *ptr){
	if(_free ==NULL){
		_free = dlsym (RTLD_NEXT,"free");
	//buscar na lista se existir chamar free original retirando p da lista
	//void *p = Busca(ptr);
	//if(p!NULL) free(p);

}
*/

int main(){
    LDE *lista  = malloc(sizeof(LDE));
    InicializaLista(lista);
    InsereNO(lista,7);
    InsereNO(lista,2);
    InsereNO(lista,3);
    InsereNO(lista,5);
    InsereNO(lista,5);
    InsereNO(lista,6);
    InsereNO(lista,7);
    ImprimeLista(lista);
    RemoveNO(lista,6);
    printf("remove\n");
    ImprimeLista(lista);


return 0;

}





