
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

typedef struct Lista {   
  void *dado;   
  struct Lista *anterior;   
  struct Lista *proximo;  
  int tamanho; 
}elemento;   

/*----------------- Funcoes para a Lista encadeada-----------------*/

void InicializaLista(){
}

void *Busca(){

}

void InsereLista(){
}

void RemoveLista(){
}

void Libera(){
}

void Imprime elemento *A) {
   if (A != NULL) {
      printf ("%d\n", A->dado);
      imprime (A->proximo);
   }
}


/*----------------- Funcoes para o mid-----------------*/


void *(*_malloc)(size_t) = NULL;

void *malloc(size_t size){

	if (!_malloc)
		_malloc = dlsym(RTLD_NEXT, "malloc");
	
	fprintf(stderr, "WRAPPER: malloc(%d) = %p\n",(int)size, p);
	void *p = _malloc(size);

	//INSERE P NUMA LISTA duplamente encadeada
	return p;
}

void * (*_calloc)(size_t, size_t) = NULL;

void *calloc(size_t nmemb, size_t size){
	if (!_calloc)
		_calloc = dlsym(RTLD_NEXT, "calloc");
	
	fprintf(stderr, "WRAPPER: mclloc(%d) = %p\n",(int)size, p);
	void *p = _calloc(nmemb, size);

	//INSERE P NUMA LISTA duplamente encadeada
	return p;
	
}


void * (*_realloc)(void *, size_t) = NULL;

void *realloc(void *ptr, size_t size){
	if (!_realloc)
		_realloc = dlsym(RTLD_NEXT, "realloc");
	
	fprintf(stderr, "WRAPPER: realloc(%d) = %p\n",(int)size, p);
	void *p = _realloc(ptr, size);

	//INSERE P NUMA LISTA duplamente encadeada
	return p;

	
}



void (*_free)(void *) = NULL;

void free(void *ptr){
	if(_free ==NULL){
		_free = dlsym (RTLD_NEXT,"free");
	//buscar na lista se existir chamar free original retirando p da lista
	
}





